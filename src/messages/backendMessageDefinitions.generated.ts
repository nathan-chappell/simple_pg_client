/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */

import { DataTypeAdapter } from '../streams/dataTypeAdapter.ts'
import { MessageWriterAdapter } from './messageWriterAdapter.ts'
import {
    Int32,
    Int16,
    Int8,
    Byte,
    Byte1,
    Char,
    String,
    parseInt32,
    parseInt16,
    parseInt8,
    parseByte,
    parseByte1,
    parseChar,
    parseString,
} from './builtinTypes.generated.ts'

///#region Backend Message Defs

/// IBackendMessage

export interface IBackendMessage {
    messageType:   String         // String
    length:        Int32          // Int32
}

export const parseIBackendMessage: (adapter: DataTypeAdapter) => Promise<IBackendMessage>
  = async (adapter: DataTypeAdapter) => {
    const messageType   = await parseString(adapter)
    const length        = await parseInt32(adapter)
    return {
        messageType,
        length,
    }
}

// No type guard

/// BackendKeyData

export interface IBackendKeyData extends IBackendMessage {
    messageType:   Byte1          // Byte1('K')
    length:        Int32          // Int32(12)
    pid:           Int32          // Int32
    key:           Int32          // Int32
}

export const parseBackendKeyData: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IBackendKeyData>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const pid           = await parseInt32(adapter)
    const key           = await parseInt32(adapter)
    return {
        ...baseMessage,
        pid,
        key,
    }
}

export function isIBackendKeyData(message: IBackendMessage): message is IBackendKeyData {
    return message.messageType === 'K'
}

/// BindComplete

export interface IBindComplete extends IBackendMessage {
    messageType:   Byte1          // Byte1('2')
    length:        Int32          // Int32(4)
}

export const parseBindComplete: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IBindComplete>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as IBindComplete)

export function isIBindComplete(message: IBackendMessage): message is IBindComplete {
    return message.messageType === '2'
}

/// CloseComplete

export interface ICloseComplete extends IBackendMessage {
    messageType:   Byte1          // Byte1('3')
    length:        Int32          // Int32(4)
}

export const parseCloseComplete: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<ICloseComplete>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as ICloseComplete)

export function isICloseComplete(message: IBackendMessage): message is ICloseComplete {
    return message.messageType === '3'
}

/// CommandComplete

export interface ICommandComplete extends IBackendMessage {
    messageType:   Byte1          // Byte1('C')
    length:        Int32          // Int32
    message:       String         // String
}

export const parseCommandComplete: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<ICommandComplete>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const message       = await parseString(adapter)
    return {
        ...baseMessage,
        message,
    }
}

export function isICommandComplete(message: IBackendMessage): message is ICommandComplete {
    return message.messageType === 'C'
}

/// CopyInResponse

export interface ICopyInResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('G')
    length:        Int32          // Int32
    isBinary:      Int8           // Int8
    formatCodes:   Int16[]        // Int16[Int16]
}

export const parseCopyInResponse: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<ICopyInResponse>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const isBinary      = await parseInt8(adapter)
    const result_0 = []
    const count_0 = await parseInt16(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        result_0.push(await parseInt16(adapter))
    }
    const formatCodes = result_0
    return {
        ...baseMessage,
        isBinary,
        formatCodes,
    }
}

export function isICopyInResponse(message: IBackendMessage): message is ICopyInResponse {
    return message.messageType === 'G'
}

/// CopyOutResponse

export interface ICopyOutResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('H')
    length:        Int32          // Int32
    isBinary:      Int8           // Int8
    formatCodes:   Int16[]        // Int16[Int16]
}

export const parseCopyOutResponse: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<ICopyOutResponse>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const isBinary      = await parseInt8(adapter)
    const result_0 = []
    const count_0 = await parseInt16(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        result_0.push(await parseInt16(adapter))
    }
    const formatCodes = result_0
    return {
        ...baseMessage,
        isBinary,
        formatCodes,
    }
}

export function isICopyOutResponse(message: IBackendMessage): message is ICopyOutResponse {
    return message.messageType === 'H'
}

/// CopyBothResponse

export interface ICopyBothResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('W')
    length:        Int32          // Int32
    isBinary:      Int8           // Int8
    formatCodes:   Int16[]        // Int16[Int16]
}

export const parseCopyBothResponse: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<ICopyBothResponse>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const isBinary      = await parseInt8(adapter)
    const result_0 = []
    const count_0 = await parseInt16(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        result_0.push(await parseInt16(adapter))
    }
    const formatCodes = result_0
    return {
        ...baseMessage,
        isBinary,
        formatCodes,
    }
}

export function isICopyBothResponse(message: IBackendMessage): message is ICopyBothResponse {
    return message.messageType === 'W'
}

/// DataRow

export interface IDataRow extends IBackendMessage {
    messageType:   Byte1          // Byte1('D')
    length:        Int32          // Int32
    columns:       Byte[][]       // Byte[Int32][Int16]
}

export const parseDataRow: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IDataRow>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const result_0 = []
    const count_0 = await parseInt32(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        const result_1 = []
        const count_1 = await parseInt16(adapter)
        for (let i_1 = 0; i_1 < count_1; ++i_1) {
            result_1.push(await parseByte(adapter))
        }
        result_0.push(result_1)
    }
    const columns = result_0
    return {
        ...baseMessage,
        columns,
    }
}

export function isIDataRow(message: IBackendMessage): message is IDataRow {
    return message.messageType === 'D'
}

/// EmptyQueryResponse

export interface IEmptyQueryResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('I')
    length:        Int32          // Int32(4)
}

export const parseEmptyQueryResponse: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IEmptyQueryResponse>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as IEmptyQueryResponse)

export function isIEmptyQueryResponse(message: IBackendMessage): message is IEmptyQueryResponse {
    return message.messageType === 'I'
}

/// ErrorResponse

export interface IErrorResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('E')
    length:        Int32          // Int32
}

export const parseErrorResponse: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IErrorResponse>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as IErrorResponse)

export function isIErrorResponse(message: IBackendMessage): message is IErrorResponse {
    return message.messageType === 'E'
}

/// NoData

export interface INoData extends IBackendMessage {
    messageType:   Byte1          // Byte1('n')
    length:        Int32          // Int32(4)
}

export const parseNoData: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<INoData>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as INoData)

export function isINoData(message: IBackendMessage): message is INoData {
    return message.messageType === 'n'
}

/// NoticeResponse

export interface INoticeResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('N')
    length:        Int32          // Int32
}

export const parseNoticeResponse: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<INoticeResponse>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as INoticeResponse)

export function isINoticeResponse(message: IBackendMessage): message is INoticeResponse {
    return message.messageType === 'N'
}

/// NotificationResponse

export interface INotificationResponse extends IBackendMessage {
    messageType:   Byte1          // Byte1('A')
    length:        Int32          // Int32
    pid:           Int32          // Int32
    channelName:   String         // String
    message:       String         // String
}

export const parseNotificationResponse: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<INotificationResponse>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const pid           = await parseInt32(adapter)
    const channelName   = await parseString(adapter)
    const message       = await parseString(adapter)
    return {
        ...baseMessage,
        pid,
        channelName,
        message,
    }
}

export function isINotificationResponse(message: IBackendMessage): message is INotificationResponse {
    return message.messageType === 'A'
}

/// ParameterDescription

export interface IParameterDescription extends IBackendMessage {
    messageType:   Byte1          // Byte1('t')
    length:        Int32          // Int32
    pTypes:        Int32[]        // Int32[Int16]
}

export const parseParameterDescription: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IParameterDescription>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const result_0 = []
    const count_0 = await parseInt16(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        result_0.push(await parseInt32(adapter))
    }
    const pTypes = result_0
    return {
        ...baseMessage,
        pTypes,
    }
}

export function isIParameterDescription(message: IBackendMessage): message is IParameterDescription {
    return message.messageType === 't'
}

/// ParameterStatus

export interface IParameterStatus extends IBackendMessage {
    messageType:   Byte1          // Byte1('S')
    length:        Int32          // Int32
    name:          String         // String
    value:         String         // String
}

export const parseParameterStatus: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IParameterStatus>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const name          = await parseString(adapter)
    const value         = await parseString(adapter)
    return {
        ...baseMessage,
        name,
        value,
    }
}

export function isIParameterStatus(message: IBackendMessage): message is IParameterStatus {
    return message.messageType === 'S'
}

/// ParseComplete

export interface IParseComplete extends IBackendMessage {
    messageType:   Byte1          // Byte1('1')
    length:        Int32          // Int32(4)
}

export const parseParseComplete: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IParseComplete>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as IParseComplete)

export function isIParseComplete(message: IBackendMessage): message is IParseComplete {
    return message.messageType === '1'
}

/// PortalSuspended

export interface IPortalSuspended extends IBackendMessage {
    messageType:   Byte1          // Byte1('s')
    length:        Int32          // Int32(4)
}

export const parsePortalSuspended: (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IPortalSuspended>
  = (_adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise.resolve(baseMessage as IPortalSuspended)

export function isIPortalSuspended(message: IBackendMessage): message is IPortalSuspended {
    return message.messageType === 's'
}

/// ReadyForQuery

export interface IReadyForQuery extends IBackendMessage {
    messageType:   Byte1          // Byte1('Z')
    length:        Int32          // Int32(5)
    status:        Char           // 'I' | 'T' | 'E'
}

export const parseReadyForQuery: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IReadyForQuery>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const status        = await parseChar(adapter)
    return {
        ...baseMessage,
        status,
    }
}

export function isIReadyForQuery(message: IBackendMessage): message is IReadyForQuery {
    return message.messageType === 'Z'
}

/// IField

export interface IField {
    name:          String         // String
    tableOid:      Int32          // Int32
    attrNo:        Int16          // Int16
    typeOid:       Int32          // Int32
    typeSize:      Int16          // Int16
    typeModifier:  Int32          // Int32
    isBinary:      Int16          // Int16
}

export const parseIField: (adapter: DataTypeAdapter) => Promise<IField>
  = async (adapter: DataTypeAdapter) => {
    const name          = await parseString(adapter)
    const tableOid      = await parseInt32(adapter)
    const attrNo        = await parseInt16(adapter)
    const typeOid       = await parseInt32(adapter)
    const typeSize      = await parseInt16(adapter)
    const typeModifier  = await parseInt32(adapter)
    const isBinary      = await parseInt16(adapter)
    return {
        name,
        tableOid,
        attrNo,
        typeOid,
        typeSize,
        typeModifier,
        isBinary,
    }
}

// No type guard

/// RowDescription

export interface IRowDescription extends IBackendMessage {
    messageType:   Byte1          // Byte1('T')
    length:        Int32          // Int32
    fields:        IField[]       // IField[Int16]
}

export const parseRowDescription: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IRowDescription>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const result_0 = []
    const count_0 = await parseInt16(adapter)
    for (let i_0 = 0; i_0 < count_0; ++i_0) {
        result_0.push(await parseIField(adapter))
    }
    const fields = result_0
    return {
        ...baseMessage,
        fields,
    }
}

export function isIRowDescription(message: IBackendMessage): message is IRowDescription {
    return message.messageType === 'T'
}

///#endregion

//#region Authentication

export interface IAuthenticationMessage extends IBackendMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32
    code:          Int32          // IField[Int16]
    salt?:         Byte[]
}


export const parseAuthenticationMessage: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IAuthenticationMessage>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const code = await adapter.readInt32();
    const result: IAuthenticationMessage = { ...baseMessage, code };
    if (code === 5) {
        const salt = [];
        for (let i = 0; i < 4; ++i) {
            salt.push(await adapter.readInt8())
        }
        result.salt = salt;
    }
    return result
}

export function isAuthenticationMessage(message: IBackendMessage): message is IAuthenticationMessage {
    return message.messageType === 'R'
}


export interface IAuthenticationOk extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(0)
}

export function isIAuthenticationOk(message: IBackendMessage): message is IAuthenticationOk {
    return isAuthenticationMessage(message) && message.code === 0
}

export interface IAuthenticationKerberosV5 extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(2)
}

export function isIAuthenticationKerberosV5(message: IBackendMessage): message is IAuthenticationKerberosV5 {
    return isAuthenticationMessage(message) && message.code === 2
}

export interface IAuthenticationCleartextPassword extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(3)
}

export function isIAuthenticationCleartextPassword(message: IBackendMessage): message is IAuthenticationCleartextPassword {
    return isAuthenticationMessage(message) && message.code === 3
}

export interface IAuthenticationMD5Password extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(12)
    code:          Int32          // Int32(5)
    salt:          Byte[]         // Byte4
}

export function isIAuthenticationMD5Password(message: IBackendMessage): message is IAuthenticationMD5Password {
    return isAuthenticationMessage(message) && message.code === 5
}

export interface IAuthenticationSCMCredential extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(6)
}

export function isIAuthenticationSCMCredential(message: IBackendMessage): message is IAuthenticationSCMCredential {
    return isAuthenticationMessage(message) && message.code === 6
}

export interface IAuthenticationGSS extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(7)
}

export function isIAuthenticationGSS(message: IBackendMessage): message is IAuthenticationGSS {
    return isAuthenticationMessage(message) && message.code === 7
}

export interface IAuthenticationSSPI extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32(8)
    code:          Int32          // Int32(9)
}

export function isIAuthenticationSSPI(message: IBackendMessage): message is IAuthenticationSSPI {
    return isAuthenticationMessage(message) && message.code === 9
}

export interface IAuthenticationSASL extends IAuthenticationMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32
    code:          Int32          // Int32(10)
}

export function isIAuthenticationSASL(message: IBackendMessage): message is IAuthenticationSASL {
    return isAuthenticationMessage(message) && message.code === 10
}

//#endregion

export const parseBackendMessage: (adapter: DataTypeAdapter) => Promise<IBackendMessage> = async (adapter) => {
    const baseMessage = await parseIBackendMessage(adapter)
    switch(baseMessage.messageType) {
        case 'R': return parseAuthenticationMessage(adapter, baseMessage)
        case 'K': return parseBackendKeyData(adapter, baseMessage)
        case '2': return parseBindComplete(adapter, baseMessage)
        case '3': return parseCloseComplete(adapter, baseMessage)
        case 'C': return parseCommandComplete(adapter, baseMessage)
        case 'G': return parseCopyInResponse(adapter, baseMessage)
        case 'H': return parseCopyOutResponse(adapter, baseMessage)
        case 'W': return parseCopyBothResponse(adapter, baseMessage)
        case 'D': return parseDataRow(adapter, baseMessage)
        case 'I': return parseEmptyQueryResponse(adapter, baseMessage)
        case 'E': return parseErrorResponse(adapter, baseMessage)
        case 'n': return parseNoData(adapter, baseMessage)
        case 'N': return parseNoticeResponse(adapter, baseMessage)
        case 'A': return parseNotificationResponse(adapter, baseMessage)
        case 't': return parseParameterDescription(adapter, baseMessage)
        case 'S': return parseParameterStatus(adapter, baseMessage)
        case '1': return parseParseComplete(adapter, baseMessage)
        case 's': return parsePortalSuspended(adapter, baseMessage)
        case 'Z': return parseReadyForQuery(adapter, baseMessage)
        case 'T': return parseRowDescription(adapter, baseMessage)
        default: throw new Error(`Failed to parse message type: '${baseMessage.messageType}'`)
    }
}

//#region Frontend Writers


export const writeBind: (messageWriterAdapter: MessageWriterAdapter, portalName: String, statementName: String, pFormats: Int16[], parameters: Byte[][], rFormats: Int16[]) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    portalName: String,
    statementName: String,
    pFormats: Int16[],
    parameters: Byte[][],
    rFormats: Int16[]
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 66 },
        {type: 'String', value: portalName, name: 'portalName'},
        {type: 'String', value: statementName, name: 'statementName'},
        {type: 'Int16[]', value: pFormats, name: 'pFormats'},
        {type: 'Byte[][]', value: parameters, name: 'parameters'},
        {type: 'Int16[]', value: rFormats, name: 'rFormats'}
])



export const writeCancelRequest: (messageWriterAdapter: MessageWriterAdapter, pid: Int32, key: Int32) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    pid: Int32,
    key: Int32
) => messageWriterAdapter.writeMessage([
        { type: 'Int32', name: 'messageType', value: undefined },
        {type: 'Int32', value: pid, name: 'pid'},
        {type: 'Int32', value: key, name: 'key'}
])



export const writeClose: (messageWriterAdapter: MessageWriterAdapter, qType: Char, name: String) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    qType: Char,
    name: String
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 67 },
        {type: 'Char', value: qType, name: 'qType'},
        {type: 'String', value: name, name: 'name'}
])



export const writeCopyFail: (messageWriterAdapter: MessageWriterAdapter, message: String) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    message: String
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 102 },
        {type: 'String', value: message, name: 'message'}
])



export const writeDescribe: (messageWriterAdapter: MessageWriterAdapter, qType: Byte1, name: String) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    qType: Byte1,
    name: String
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 68 },
        {type: 'Byte1', value: qType, name: 'qType'},
        {type: 'String', value: name, name: 'name'}
])



export const writeExecute: (messageWriterAdapter: MessageWriterAdapter, name: String, limit: Int32) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    name: String,
    limit: Int32
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 69 },
        {type: 'String', value: name, name: 'name'},
        {type: 'Int32', value: limit, name: 'limit'}
])



export const writeFlush: (messageWriterAdapter: MessageWriterAdapter) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 72 }
])



export const writeParse: (messageWriterAdapter: MessageWriterAdapter, name: String, query: String, pTypes: Int32[]) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    name: String,
    query: String,
    pTypes: Int32[]
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 80 },
        {type: 'String', value: name, name: 'name'},
        {type: 'String', value: query, name: 'query'},
        {type: 'Int32[]', value: pTypes, name: 'pTypes'}
])



export const writePasswordMessage: (messageWriterAdapter: MessageWriterAdapter, password: String) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    password: String
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 112 },
        {type: 'String', value: password, name: 'password'}
])



export const writeQuery: (messageWriterAdapter: MessageWriterAdapter, query: String) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    query: String
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 81 },
        {type: 'String', value: query, name: 'query'}
])



export const writeSSLRequest: (messageWriterAdapter: MessageWriterAdapter) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter
) => messageWriterAdapter.writeMessage([
        { type: 'Int32', name: 'messageType', value: undefined }
])



export const writeStartupMessage: (messageWriterAdapter: MessageWriterAdapter, protocol: Int32) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter,
    protocol: Int32
) => messageWriterAdapter.writeMessage([
        {type: 'Int32', value: protocol, name: 'protocol'}
])



export const writeSync: (messageWriterAdapter: MessageWriterAdapter) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 83 }
])



export const writeTerminate: (messageWriterAdapter: MessageWriterAdapter) => Promise<void>
  = (
    messageWriterAdapter: MessageWriterAdapter
) => messageWriterAdapter.writeMessage([
        { type: 'Int8', name: 'messageType', value: 88 }
])


//#endregion


/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */