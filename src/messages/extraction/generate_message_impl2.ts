import { writeFileSync } from 'https://deno.land/std@0.161.0/node/fs.ts'
import { formats, IMessageField, IMessageFormat } from './formats.ts'
import { TypeInfo } from './typeInfo.ts'
import { ITextCompiler } from '../../compilers/ITextCompiler.ts'
import { Region } from '../../structures/Region.ts'
import { TextCompiler } from "../../compilers/TextCompiler.ts";

const validateStartup = () => {
    const cwd = Deno.cwd()
    if (!cwd.endsWith('simple_pg_client')) {
        throw new Error(`Generation script should be run from project root.\n  cwd: ${cwd}`)
    } else {
        console.log(`[validateStartup] cwd: ${cwd}`)
    }
}

validateStartup()

//#region globals
const builtinsFileName = 'builtinTypes'
const warning = `/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */`

export type TBuiltinTypeInfo = { jsType: string; adapterType: string }

//prettier-ignore
export const builtinTypes: { [type: string]: TBuiltinTypeInfo } = {
    Int32:  { jsType: 'number',     adapterType: 'Int32' },
    Int16:  { jsType: 'number',     adapterType: 'Int16' },
    Int8:   { jsType: 'number',     adapterType: 'Int8' },
    Byte:   { jsType: 'number',     adapterType: 'Int8' },
    Byte1:  { jsType: 'string',     adapterType: 'Char' },
    Byte4:  { jsType: 'number[]',   adapterType: 'Byte4' },
    String: { jsType: 'string',     adapterType: 'String' },
    // Char:   { jsType: 'string',   adapterType: 'Char'   }, // no longer used...
}

export type ArrayType = { rawType: string; itemType: ArrayType | string; sizeType: 'Int16' | 'Int32' }

export const isArrayRawType = (type: string) => type.match(/\[\w+\]/) !== null

export const _getArrayType: (rawType: string) => ArrayType = rawType => {
    if (!isArrayRawType(rawType)) throw new Error(`Couldn't get ArrayType from ${rawType}`)
    const { rest, sizeType } = rawType.match(/^(?<rest>.*)\[(?<sizeType>\w+)\]$/)!.groups!
    const itemType = isArrayRawType(rest) ? _getArrayType(rest) : rest
    if (sizeType !== 'Int16' && sizeType !== 'Int32') {
        throw new Error(`Invalid sizeType: ${sizeType} in ${rawType}`)
    } else {
        return { rawType, itemType, sizeType }
    }
}

//#endregion

//#region imports

const writeImports = (compiler: ITextCompiler) => {
    compiler.writeImports(['DataTypeAdapter'], '../streams/dataTypeAdapter.ts')
    compiler.writeImports(['MessageWriterAdapter'], './messageWriterAdapter.ts')
    const builtinImports = [
        ...Object.keys(builtinTypes),
        ...Object.keys(builtinTypes).map(t => `parse${t}`),
    ]
    compiler.writeImports(builtinImports, `./${builtinsFileName}.generated.ts`)
}

//#endregion

//#region builtins

// prettier-ignore
const builtinFunction_ = (name: string) => new Function_(
    `parse${name}`,
    [new Parameter('adapter', 'DataTypeAdapter')],
    `Promise<${name}>`,
    { export_: true, arrow_: true, const_: true, expressionBody_: true, }
)

const genBuiltins2 = (compiler: ITextCompiler) => {
    compiler.writeImports(['DataTypeAdapter'], '../streams/dataTypeAdapter.ts').newLine()
    const fnDefInfo: [Function_, () => void][] = []
    for (const name of Object.keys(builtinTypes)) {
        const { jsType, adapterType } = builtinTypes[name]
        compiler.writeType(name, jsType, { export_: true })
        // prettier-ignore
        fnDefInfo.push([
            builtinFunction_(name),
            () => { compiler.writeLine(`adapter.read${adapterType}()`) }
        ])
    }
    compiler.newLine()
    for (const info of fnDefInfo) compiler.writeFunction_(...info)
    compiler.newLine()
}

//#endregion

//#region interfaces

const getInterface: (format: IMessageFormat) => Interface = format => {
    const properties: InterfacePropertyOptions[] = []
    for (const property of format.definition) {
        properties.push({
            name: property.name,
            type: new TypeInfo(property.type).tsType,
            comment: property.definition,
        })
    }
    return new Interface(format.title, properties, { export_: true })
}

//#endregion

//#region Parsers

type ResultName = string

class GenPropertyParser {
    typeInfo: TypeInfo
    _typeAlignment = 10
    _initAlignment = 20

    constructor(public property: IMessageField) {
        this.typeInfo = new TypeInfo(property.type)
    }

    // f = async () => {
    //     let p: 'type[][]';
    //     {
    //         let result_0: 'type[]' = [];
    //         let count = await parseCount(adapter)
    //         for (let i_0 = 0; i < count; ++i) {
    //             // ...
    //             result_0.push(result_1)
    //         }
    //         p = result_0
    //     }
    // }

    writeArrayParser(type: ArrayType | string, depth = 0): ResultName {
        const resultName = `result_${depth}`
        const loopIndexName = `i_${depth}`
        const sizeName = `size_${depth}`

        const resultVar = new Variable()

        if (typeof type === 'string') {
            const variable = new Variable()
        } else {
            // parse size
            // recurse
        }
    }

    write(compiler: ITextCompiler): ITextCompiler {
        // if (this.typeInfo.isBuiltin) {
        const variable = new Variable(this.property.name, this.typeInfo.tsType, {
            initAlignment: this._initAlignment,
            typeAlignment: this._typeAlignment,
        })
        if (this.typeInfo.arrayType === null) {
            variable.options.const_ = true
            variable.options.initializer_ = `await parse${this.typeInfo.adapterType}(adapter)`
            return variable.write(compiler)
        } else {
            variable.write(compiler)
            compiler.withBlock(() => {
                this.writeArrayParser(this.typeInfo.arrayType)
                variable.writeAssignment(compiler, 'result_0')
            })
            // parseArrayStuff
        }
        return compiler
    }
}

//#endregion

const genFile2 = (fileName: string, writeFile: (compiler: ITextCompiler) => void) => {
    const path = `./src/messages/${fileName}.generated.ts`
    console.log(`[genFile2] Generating file ${fileName} ...`)
    const compiler = new TextCompiler()
    writeFile(compiler)
    /// FILE
    const file = `${warning}\n${compiler.compile()}\n${warning}`
    writeFileSync(path, file)
    console.log(`[genFile2] Generating file ${fileName} complete`)
}

genFile2(builtinsFileName, genBuiltins2)

genFile2('genTesting', compiler => {
    writeImports(compiler)
    compiler.build(new Region('INTERFACES'), () => {
        for (const format of formats) {
            const interface_ = getInterface(format)
            interface_.write(compiler)
        }
    })
})
