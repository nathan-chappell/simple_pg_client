import { writeFileSync } from 'https://deno.land/std@0.161.0/node/fs.ts'
import { formats, IProperty, IMessageDef } from './formats.ts'
import { GenWriter } from '../../generators/genWriter.ts'
import { FunctionDef } from '../../generators/functionDef.ts'
import { ParameterDef } from '../../generators/parameterDef.ts'
import { GenWriterBase } from '../../generators/genWriterBase.ts'
import { InterfacePropertyOptions } from '../../generators/options.ts'
import { InterfaceDef } from '../../generators/interfaceDef.ts'
import { ArrayPrototypeFilter } from 'https://deno.land/std@0.161.0/node/internal/primordials.mjs'

const validateStartup = () => {
    const cwd = Deno.cwd()
    if (!cwd.endsWith('simple_pg_client')) {
        throw new Error(`Generation script should be run from project root.\n  cwd: ${cwd}`)
    } else {
        console.log(`[validateStartup] cwd: ${cwd}`)
    }
}

validateStartup()

//#region globals
const builtinsFileName = 'builtinTypes'
const warning = `/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */`

//prettier-ignore
type TBuiltinTypeInfo = { jsType: string; adapterType: string }

const builtinTypes: { [type: string]: TBuiltinTypeInfo } = {
    Int32: { jsType: 'number', adapterType: 'Int32' },
    Int16: { jsType: 'number', adapterType: 'Int16' },
    Int8: { jsType: 'number', adapterType: 'Int8' },
    Byte: { jsType: 'number', adapterType: 'Int8' },
    Byte1: { jsType: 'string', adapterType: 'Char' },
    Byte4: { jsType: 'number[]', adapterType: 'Byte4' },
    String: { jsType: 'string', adapterType: 'String' },
    // Char:   { jsType: 'string',   adapterType: 'Char'   }, // no longer used...
}

type ArrayType = { itemType: ArrayType | string; sizeType: 'Int16' | 'Int32' }

const isArrayRawType = (type: string) => type.match(/\[\w+\]/) !== null

const _getArrayType: (type: string) => ArrayType = type => {
    if (!isArrayRawType(type)) throw new Error(`Couldn't get ArrayType from ${type}`)
    const { rest, sizeType } = type.match(/^(?<rest>.*)\[(?<sizeType>\w+)\]$/)!.groups!
    const itemType = isArrayRawType(rest) ? _getArrayType(rest) : rest
    if (sizeType !== 'Int16' && sizeType !== 'Int32') {
        throw new Error(`Invalid sizeType: ${sizeType} in ${type}`)
    } else {
        return { itemType, sizeType }
    }
}

class TypeInfo {
    arrayType: ArrayType | null
    expected: string | null
    rawType: string
    tsType: string
    builtinTypeInfo: TBuiltinTypeInfo | null = null

    constructor(rawType: string) {
        this.rawType = rawType
        const _expectedMatch = rawType.match(/^(?<rest>[^()]*)(?<expected>\(\w+\))$/)
        if (!_expectedMatch) throw new Error(`Couldn't get TypeInfo for ${rawType}`)
        this.expected = _expectedMatch.groups!.expected ?? null
        const rawTypeNoExpected = _expectedMatch.groups!.rest
        this.tsType = rawTypeNoExpected.replace(/\[[^\]]+\]/g, '[]').replace(/\(.*/, '')
        this.arrayType = isArrayRawType(rawTypeNoExpected) ? _getArrayType(rawTypeNoExpected) : null
        this.builtinTypeInfo = builtinTypes[rawTypeNoExpected] ?? null
    }

    get isBuiltin() {
        return this.builtinTypeInfo !== null
    }

    get adapterType(): string {
        if (!this.isBuiltin)
            throw new Error(`Tried getting adapterType from non-builtin-type ${this.rawType}`)
        return this.builtinTypeInfo!.adapterType!
    }
}

//#endregion

//#region imports

const writeImports = (writer: GenWriter) => {
    writer.writeImports(['DataTypeAdapter'], '../streams/dataTypeAdapter.ts')
    writer.writeImports(['MessageWriterAdapter'], './messageWriterAdapter.ts')
    const builtinImports = [...Object.keys(builtinTypes), ...Object.keys(builtinTypes).map(t => `parse${t}`)]
    writer.writeImports(builtinImports, `./${builtinsFileName}.generated.ts`)
}

//#endregion

//#region builtins

// prettier-ignore
const builtinFunctionDef = (name: string) => new FunctionDef(
    `parse${name}`,
    [new ParameterDef('adapter', 'DataTypeAdapter')],
    `Promise<${name}>`,
    { export_: true, arrow_: true, const_: true, expressionBody_: true, }
)

const genBuiltins2 = (writer: GenWriter) => {
    writer.writeImports(['DataTypeAdapter'], '../streams/dataTypeAdapter.ts').newLine()
    const fnDefInfo: [FunctionDef, () => void][] = []
    for (const name of Object.keys(builtinTypes)) {
        const { jsType, adapterType } = builtinTypes[name]
        writer.writeTypeDef(name, jsType, { export_: true })
        // prettier-ignore
        fnDefInfo.push([
            builtinFunctionDef(name),
            () => { writer.writeLine(`adapter.read${adapterType}()`) }
        ])
    }
    writer.newLine()
    for (const info of fnDefInfo) writer.writeFunction(...info)
    writer.newLine()
}

//#endregion

//#region interfaces

const getInterfaceDef: (messageDef: IMessageDef) => InterfaceDef = messageDef => {
    const properties: InterfacePropertyOptions[] = []
    for (const property of messageDef.definition) {
        properties.push({
            name: property.name,
            type: new TypeInfo(property.type).tsType,
            comment: property.definition,
        })
    }
    return new InterfaceDef(messageDef.title, properties, { export_: true })
}

//#endregion

//#region Parsers

class GenPropertyParser {
    typeInfo: TypeInfo
    _assignmentAlignment = 20

    constructor(public property: IProperty) {
        this.typeInfo = new TypeInfo(property.type)
    }

    write(writer: GenWriterBase): GenWriterBase {
        // if (this.typeInfo.isBuiltin) {
        if (this.typeInfo.arrayType === null) {
            writer
                .write(`const ${this.property.name}`)
                .align(this._assignmentAlignment)
                .write(`= await parse${this.typeInfo.adapterType}(adapter)`)
        } else {
            //
        }
        return writer
    }
}

//#endregion

const genFile2 = (fileName: string, writeFile: (writer: GenWriter) => void) => {
    const path = `./src/messages/${fileName}.generated.ts`
    console.log(`[genFile2] Generating file ${fileName} ...`)
    const writer = new GenWriter()
    writeFile(writer)
    /// FILE
    const file = `${warning}\n${writer.compile()}\n${warning}`
    writeFileSync(path, file)
    console.log(`[genFile2] Generating file ${fileName} complete`)
}

genFile2(builtinsFileName, genBuiltins2)

genFile2('genTesting', writer => {
    writeImports(writer)
    writer.withRegion('INTERFACES', () => {
        for (const messageDef of formats) {
            const interfaceDef = getInterfaceDef(messageDef)
            interfaceDef.write(writer)
        }
    })
})
