import { writeFileSync } from "https://deno.land/std@0.161.0/node/fs.ts";
import { formats, ITypeDef, IProperty } from './formats.ts'

const ensureInterface = (s: string) => (
    s.startsWith('I')
    || s.startsWith('Byte')
    || s.startsWith('String')
 ) ? s : `I${s}`;

const warning = `/* DO NOT EDIT THIS FILE!!! */`

const parserImports = `import builtin from './builtinParsers.ts'
import { DataTypeAdapter } from "../streams/dataTypeAdapter.ts";`

// Authentication messages are trickier and will be handled separately
const backendFormats = formats.filter(f => f.title.match(/\(B\)/) && !f.title.match(/IBackendMessage|Authentication/))

const getProp = (name: string, type: ITypeParserDef) => {
    if (!type.arraySpec) {
        return `    const ${name} = await builtin.${type.baseType}(adapter);`
    } else {
        // 
    }
}

const fnTemplater = (messageType: string, props: string[][]) => `
export const parse${messageType}: (adapter: DataTypeAdapter, baseProps: IBackendMessage) => Promise<${ensureInterface(messageType)}> = async (adapter, baseProps) => {
${props.map(([name, parser]) => `    const ${name} = await builtin.${parser}(adapter);`).join("\n")}
    return {
        ...baseProps,
${props.map(([name,_]) => `        ${name},`).join("\n")}
    } as ${ensureInterface(messageType)}
}`;

const fnTemplaterNoProps = (messageType: string) => `
export const parse${messageType}: (adapter: DataTypeAdapter, baseProps: IBackendMessage) => Promise<${ensureInterface(messageType)}> 
    = (_, baseProps) => Promise.resolve(baseProps as ${ensureInterface(messageType)});`;

interface ITypeParserDef {
    baseType: string
    arraySpec?: string
}

const getType: (typeSpec: string) => ITypeParserDef = (typeSpec) => {
    // literal / intensional types
    if (typeSpec.includes("|") && typeSpec.includes("'"))
        return { baseType: 'Byte1'};

    const { baseType, expected, arraySpec } = typeSpec.match(/^(?<baseType>\w+)(?<arraySpec>(\[\w+\])*)(\((?<expected>[^)]*)\))?/)!.groups!;
    return { baseType: ensureInterface(baseType), arraySpec }
}

const getParser = (def: ITypeParserDef) => {
    if (!def.arraySpec) {
        return `parse${def.baseType}`;
    } else {

        return `parse_NOT_IMPLEMENTED`
    }
}

const needTypes = new Set(['IBackendMessage']);

function genParser(format: ITypeDef) {
    const typeName = format.title.match(/^\w+/)![0]
    const _typeName = typeName.startsWith('I') ? typeName : `I${typeName}`;
    needTypes.add(_typeName);
    const props = format.definition.slice(2).map(prop => [prop.name, getParser(getType(prop.type))])
    if (props.length === 0) {
        return fnTemplaterNoProps(typeName)
    } else {
        return fnTemplater(typeName, props);
    }
}

function genBackendParsers(name: string, formatList: ITypeDef[]) {
    const parserDefs = formatList.map(genParser)
    const typeImports = `import {
${[...needTypes].map(t => `    ${t},`).join("\n")}
} from './backendFormats.generated.ts'`;

    const fileData = `${warning}

${parserImports}
${typeImports}
${parserDefs.join("\n\n")}`
    writeFileSync(`./src/messages/${name}.generated.ts`, fileData)
}

genBackendParsers('backendMessageParsers', backendFormats)