import { writeFileSync } from 'https://deno.land/std@0.161.0/node/fs.ts'
import { formats, IProperty, IMessageDef } from './formats.ts'

const validateStartup = () => {
    const cwd = Deno.cwd()
    if (!cwd.endsWith('simple_pg_client')) {
        throw new Error(`Generation script should be run from project root.\n  cwd: ${cwd}`)
    } else {
        console.log(`[validateStartup] cwd: ${cwd}`)
    }
}

validateStartup()

//#region globals
const builtinsFileName = 'builtinTypes'
const backendMessageDefsFileName = 'backendMessageDefinitions'

const indent = (n: number) => (s: string) => ' '.repeat(n) + s

const alignOnColumn = (pre: string, alignment: number, post: string) => {
    const count = alignment - pre.length
    if (count <= 0) console.warn(`Non-positive alignment count for ${pre}...${post}`)
    return `${pre}${indent(Math.max(0, alignment - pre.length))(post)}`
}

const warning = `/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */`

// Authentication messages are trickier and will be handled separately
const backendNonAuthenticationFormats = formats.filter(f => f.backend && !f.title.match(/Authentication/))

const nonInternalMessageDefs = new Set(formats.filter(f => !f.internal).map(f => f.title))
const internalMessageDefs = new Set(formats.filter(f => f.internal).map(f => f.title))

// const builtinTypes: { [type: string]: { [attr: string]: string } } = {
const builtinTypes: { [type: string]: { jsType: string; adapterType: string } } = {
    Int32: { jsType: 'number', adapterType: 'Int32' },
    Int16: { jsType: 'number', adapterType: 'Int16' },
    Int8: { jsType: 'number', adapterType: 'Int8' },
    Byte: { jsType: 'number', adapterType: 'Int8' },
    Byte1: { jsType: 'string', adapterType: 'Char' },
    Char: { jsType: 'string', adapterType: 'Char' },
    String: { jsType: 'string', adapterType: 'String' },
}

const dataAdapterImport = "import { DataTypeAdapter } from '../streams/dataTypeAdapter.ts'"
const messageWriterImport = "import { MessageWriterAdapter } from './messageWriterAdapter.ts'"
// prettier-ignore
const imports = `
${dataAdapterImport}
${messageWriterImport}
import {
${[...Object.keys(builtinTypes)].map(t => `${t},`).map(indent(4)).join('\n')}
${[...Object.keys(builtinTypes)].map(t => `parse${t},`).map(indent(4)).join('\n')}
} from './${builtinsFileName}.generated.ts'
`

//#endregion

//#region builtins

const getBuiltinTypeAttr = (type: string, attr: 'jsType' | 'adapterType') => {
    const attrValue = (builtinTypes[type] || {})[attr]
    if (attrValue === undefined) throw new Error(`[getBuiltinTypeAttr] couldn't find ${type}.${attr}`)
    return attrValue
}

const genBuiltins = () => {
    const genTypeExport = (name: string) => `export type ${name} = ${getBuiltinTypeAttr(name, 'jsType')};`
    const genParserDefinition = (name: string) =>
        `export const parse${name} = (adapter: DataTypeAdapter) => adapter.read${getBuiltinTypeAttr(
            name,
            'adapterType'
        )}();`

    /// FILE
    return `
${dataAdapterImport}

${Object.keys(builtinTypes).map(genTypeExport).join('\n')}

${Object.keys(builtinTypes).map(genParserDefinition).join('\n')}
`
}

//#endregion

//#region ITypeInfo

type TArraySizeInfo = ('Int16' | 'Int32')[]

interface ITypeInfo {
    arraySizeInfo: TArraySizeInfo
    expected: string | null
    rawName: string
    typeNoArray: string
    typeNoExpected: string
    typeScriptName: string
}

const getArraySizeInfo: (rawName: string) => TArraySizeInfo = (rawName: string) =>
    [...rawName.matchAll(/\[(Int16|Int32)\]/g)].map(m => m[1]).reverse() as TArraySizeInfo

const substrTo = (s: string, c: string) => (s.includes(c) ? s.substring(0, s.indexOf(c)) : s)
const getTypeNoArray = (rawName: string) => substrTo(rawName, '[')
const getTypeNoExpected = (rawName: string) => substrTo(rawName, '(')
const getExpected = (rawName: string) =>
    (rawName.match(/[^(]*\((?<expected>[^)]*)\)/)?.groups ?? {}).expected ?? null

const getTypeScriptName = (rawName: string) => {
    const typeNoExpected = getTypeNoExpected(rawName)
    if (rawName === 'Byte4') {
        return 'Byte[]'
    } else if (typeNoExpected in builtinTypes) {
        return typeNoExpected
    } else if (typeNoExpected.includes('|')) {
        return 'Char'
    } else if (nonInternalMessageDefs.has(typeNoExpected)) {
        return `I${typeNoExpected}`
    } else if (internalMessageDefs.has(typeNoExpected)) {
        return typeNoExpected
    } else if (typeNoExpected.match(/\[\w+\]/)) {
        const typeNoArray = getTypeNoArray(typeNoExpected)
        const baseTypeNoArray: string = getTypeScriptName(typeNoArray)
        const rank = Array.from(typeNoExpected.matchAll(/\[\w+\]/g)).length
        return `${baseTypeNoArray}${'[]'.repeat(rank)}`
    } else {
        throw new Error(`[getTypeScriptTypeName]: Can't convert type: ${typeNoExpected}`)
    }
}

const getTypeInfo: (rawName: string) => ITypeInfo = rawName => {
    const typeScriptName = getTypeScriptName(rawName)
    const typeNoArray = getTypeNoArray(rawName)
    const typeNoExpected = getTypeNoExpected(getTypeNoArray(rawName))
    const arraySizeInfo = getArraySizeInfo(rawName)
    const expected = getExpected(rawName)

    return {
        arraySizeInfo,
        expected,
        rawName,
        typeNoArray,
        typeNoExpected,
        typeScriptName,
    }
}

//#endregion

//#region interfaces

const getBaseInterface = (name: string) => {
    if (name.match(/Authentication/)) return 'IAuthenticationMessage'
    switch (name) {
        case 'IBackendMessage':
        case 'IField':
            return ''
        default:
            return 'IBackendMessage'
    }
}

const getInterfaceProperty = (property: IProperty, i: number) => {
    if (!property.name) throw new Error(`name missing from definition[${i || 0}]: ${property.definition}`)
    const typeInfo = getTypeInfo(property.type)
    const decl = alignOnColumn(`${property.name}:`, 15, `${typeInfo.typeScriptName}`)
    return alignOnColumn(decl, 30, `// ${property.type}`)
}

const genInterface = (messageDef: IMessageDef) => {
    const interfaceName = getTypeScriptName(messageDef.title)
    try {
        const properties = messageDef.definition.map(getInterfaceProperty)
        const baseInterface = getBaseInterface(interfaceName)
        const extendsClause = messageDef.frontend || baseInterface === '' ? '' : `extends ${baseInterface} `

        return [
            `export interface ${interfaceName} ${extendsClause}{`,
            ...properties.map(indent(4)),
            `}`,
        ].join('\n')
    } catch (e) {
        throw new Error(`Error creating type ${messageDef.title}: ${e}`)
    }
}

//#endregion

//#region parsers

const getPropertyParser = (property: IProperty) => {
    const typeInfo = getTypeInfo(property.type)
    // prettier-ignore
    if (typeInfo.typeScriptName in builtinTypes) {
        const adapterType = getBuiltinTypeAttr(typeInfo.typeScriptName, 'adapterType')

        return indent(4)(alignOnColumn(`const ${property.name}`, 20, `= await parse${adapterType}(adapter)`))
    } else if (typeInfo.arraySizeInfo.length > 0) {
        const lines = []
        const sizeInfo = [...typeInfo.arraySizeInfo].reverse()
        for (let loopDepth = 0; loopDepth < sizeInfo.length; ++loopDepth) {
            const i_                = `i_${loopDepth}`
            const count_            = `count_${loopDepth}`
            const result_           = `result_${loopDepth}`
            
            const declareResult     = `const ${result_} = []`
            const parseCount        = `const ${count_} = await parse${sizeInfo[loopDepth]}(adapter)`;
            if (!sizeInfo[loopDepth]) {
                throw new Error(`sizeInfo error: ${JSON.stringify(typeInfo)}`)
            }
            const parseInLoop       = `for (let ${i_} = 0; ${i_} < ${count_}; ++${i_}) {`

            lines.push(...[declareResult, parseCount, parseInLoop].map(indent(4*loopDepth)))
        }
        {
            const result_           = `result_${sizeInfo.length - 1}`
            const parseItem         = `${result_}.push(await parse${typeInfo.typeNoArray}(adapter))`

            lines.push(...[parseItem].map(indent(4 * sizeInfo.length)))
        }
        for (let loopDepth = sizeInfo.length - 2; loopDepth >= 0; --loopDepth) {
            const result_           = `result_${loopDepth}`
            const innerResult_      = `result_${loopDepth + 1}`
            const pushInnerResult   = `${result_}.push(${innerResult_})`

            lines.push(...['}', pushInnerResult].map(indent(4 * (loopDepth + 1))))
        }
        {
            const result_           = `result_0`
            const assignToProp      = `const ${property.name} = ${result_}`

            lines.push('}', assignToProp)
        }
        return lines.map(indent(4)).join('\n')
    } else {
        throw new Error([
            `[getPropertyParser] failed with property:`,
            `${JSON.stringify(typeInfo)}`,
            `${JSON.stringify(property)}`,
        ].join("\n"))
    }
}

const genParser = (messageDef: IMessageDef) => {
    const hasBaseMessage = !messageDef.internal
    const nonBaseProperties = hasBaseMessage ? messageDef.definition.slice(2) : messageDef.definition.slice()
    const adapter_ = nonBaseProperties.length == 0 ? '_adapter' : 'adapter'
    const messageTypeInfo = getTypeInfo(messageDef.title)
    const parameterList = hasBaseMessage
        ? `${adapter_}: DataTypeAdapter, baseMessage: IBackendMessage`
        : `${adapter_}: DataTypeAdapter`

    const parserType = `(${parameterList}) => Promise<${messageTypeInfo.typeScriptName}>`
    if (nonBaseProperties.length === 0) {
        // prettier-ignore
        return [
            `export const parse${messageDef.title}: ${parserType}`,
            indent(2)( `= (${parameterList}) => Promise.resolve(baseMessage as ${messageTypeInfo.typeScriptName})`),
        ].join('\n')
    } else {
        const propertyParsers = nonBaseProperties.map(getPropertyParser)
        const resultBody = ['...baseMessage', ...nonBaseProperties.map(p => `${p.name}`)].map(s => `${s},`)
        if (!hasBaseMessage) resultBody.shift()

        return [
            `export const parse${messageDef.title}: ${parserType}`,
            indent(2)(`= async (${parameterList}) => {`),
            ...propertyParsers,
            indent(4)('return {'),
            ...resultBody.map(indent(8)),
            indent(4)('}'),
            `}`,
        ].join('\n')
    }
}

//#endregion

//#region main type-guards

const genTypeGuard = (messageDef: IMessageDef) => {
    const messageTypeInfo = getTypeInfo(messageDef.title)
    const parameterTypeInfo = getTypeInfo(messageDef.definition[0].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(messageDef)}`)
    const open = `export function is${messageTypeInfo.typeScriptName}(message: IBackendMessage): message is ${messageTypeInfo.typeScriptName} {`
    const body = `return message.messageType === ${parameterTypeInfo.expected}`
    const close = '}'
    return [open, indent(4)(body), close].join('\n')
}

//#endregion

//#region authentication

const genBackendAuthenticationParser = () => `
export const parseAuthenticationMessage: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IAuthenticationMessage>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const code = await adapter.readInt32();
    const result: IAuthenticationMessage = { ...baseMessage, code };
    if (code === 5) {
        const salt = [];
        for (let i = 0; i < 4; ++i) {
            salt.push(await adapter.readInt8())
        }
        result.salt = salt;
    }
    return result
}`

const genBackendAuthenticationTypeGuard = (messageDef: IMessageDef) => {
    const messageTypeInfo = getTypeInfo(messageDef.title)
    const parameterTypeInfo = getTypeInfo(messageDef.definition[2].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(messageDef)}`)
    const open = `export function is${messageTypeInfo.typeScriptName}(message: IBackendMessage): message is ${messageTypeInfo.typeScriptName} {`
    const body = `return isAuthenticationMessage(message) && message.code === ${parameterTypeInfo.expected}`
    const close = '}'
    return [open, indent(4)(body), close].join('\n')
}

const genBackendAuthentication = () => {
    const IAuthenticationMessage_ = `
export interface IAuthenticationMessage extends IBackendMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32
    code:          Int32          // IField[Int16]
    salt?:         Byte[]
}

${genBackendAuthenticationParser()}

export function isAuthenticationMessage(message: IBackendMessage): message is IAuthenticationMessage {
    return message.messageType === 'R'
}
`
    const getAuthentication = (messageDef: IMessageDef) =>
        [genInterface(messageDef), genBackendAuthenticationTypeGuard(messageDef)].join('\n\n')
    return [
        IAuthenticationMessage_,
        ...formats.filter(f => f.title.match(/^Authentication/)).map(getAuthentication),
    ].join('\n\n')
}

//#endregion

//#region backendMessageParser

const genCaseForMessageDef = (messageDef: IMessageDef) => {
    const messageTypeInfo = getTypeInfo(messageDef.title)
    const parameterTypeInfo = getTypeInfo(messageDef.definition[0].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(messageDef)}`)
    return `case ${parameterTypeInfo.expected}: return parse${messageTypeInfo.rawName}(adapter, baseMessage)`
}

const genBackendMessageParser = () => {
    return `export const parseBackendMessage: (adapter: DataTypeAdapter) => Promise<IBackendMessage> = async (adapter) => {
    const baseMessage = await parseIBackendMessage(adapter)
    switch(baseMessage.messageType) {
        case 'R': return parseAuthenticationMessage(adapter, baseMessage)
${backendNonAuthenticationFormats
    .filter(t => !t.internal)
    .map(genCaseForMessageDef)
    .map(indent(8))
    .join('\n')}
        default: throw new Error(\`Failed to parse message type: '\$\{baseMessage.messageType\}'\`)
    }
}`
}

//#endregion

//#region frontend message writing

const genMessageWriter = (messageDef: IMessageDef) => {
    // const messageTypeInterface = genInterface(messageDef)
    // const messageTypeProperties = messageDef.definition.map(getInterfaceProperty)
    const nonDefaultProperties = messageDef.definition.filter(
        p => p.name !== 'length' && p.name !== 'messageType'
    )

    const messageTypeParameterList = nonDefaultProperties.map(property => {
        const propertyTypeInfo = getTypeInfo(property.type)
        return `${property.name}: ${propertyTypeInfo.typeScriptName}`
    })

    const messageTypeTVList = nonDefaultProperties.map(property => {
        const propertyTypeInfo = getTypeInfo(property.type)
        return `{type: '${propertyTypeInfo.typeScriptName}', value: ${property.name}, name: '${property.name}'}`
    })

    const messageTypeProperty = messageDef.definition.find(p => p.name === 'messageType')
    if (messageTypeProperty) {
        const messageTypeTypeInfo = getTypeInfo(messageTypeProperty.type)
        const expected = (messageTypeTypeInfo.expected?.match(/'(.)'|(\d+)/) || [null, null])[1]
        if (expected === null) {
            throw new Error(`[genMessageWriter] invalid expected message type: ${JSON.stringify(messageDef)}`)
        } else {
            const _expected = typeof expected === 'string' ? expected.charCodeAt(0) : expected;
            const _type = messageTypeTypeInfo.typeScriptName === 'Byte1' ? 'Int8' : messageTypeTypeInfo.typeScriptName;
            messageTypeTVList.unshift(`{ type: '${_type}', name: 'messageType', value: ${_expected} }`)
        }
    }

    const parameterList = [`messageWriterAdapter: MessageWriterAdapter`, ...messageTypeParameterList]
    const writerType = `(${parameterList.join(', ')}) => Promise<void>`

    const messageWriter = `
export const write${messageDef.title}: ${writerType}
  = (
${parameterList.map(indent(4)).join(',\n')}
) => messageWriterAdapter.writeMessage([
${messageTypeTVList.map(indent(8)).join(',\n')}
])
`
    return messageWriter
    // return [messageTypeInterface, messageWriter].join('\n\n')
}

//#endregion

//#region main()

const genFile = (fileName: string, genFile: () => string) => {
    const path = `./src/messages/${fileName}.generated.ts`
    console.log(`[genFile] Generating file ${fileName} ...`)
    /// FILE
    const file = `${warning}\n${genFile()}\n${warning}`
    writeFileSync(path, file)
    console.log(`[genFile] Generating file ${fileName} complete`)
}

const getCodeForMessageDef = (messageDef: IMessageDef) => {
    const header = `/// ${messageDef.title}`
    const interface_ = genInterface(messageDef)
    const parser = genParser(messageDef)
    const typeGuard = messageDef.internal ? '// No type guard' : genTypeGuard(messageDef)
    return [header, interface_, parser, typeGuard].join('\n\n')
}

const genBackendMessageDefs = () => `${imports}
///#region Backend Message Defs

${backendNonAuthenticationFormats.map(getCodeForMessageDef).join('\n\n')}

///#endregion

//#region Authentication
${genBackendAuthentication()}

//#endregion

${genBackendMessageParser()}

//#region Frontend Writers

${formats
    .filter(f => f.frontend)
    .map(genMessageWriter)
    .join('\n\n')}

//#endregion

`

genFile(builtinsFileName, genBuiltins)
genFile(backendMessageDefsFileName, genBackendMessageDefs)

//#endregion
