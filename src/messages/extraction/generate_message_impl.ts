import { writeFileSync } from 'https://deno.land/std@0.161.0/node/fs.ts'
import { formats, IMessageField, IMessageFormat } from './formats.ts'
import { Parameter, Function_, GenWriter } from '../../generators/genWriter.ts'
import { ITextCompiler } from '../../generators/genWriterBase.ts'

const validateStartup = () => {
    const cwd = Deno.cwd()
    if (!cwd.endsWith('simple_pg_client')) {
        throw new Error(`Generation script should be run from project root.\n  cwd: ${cwd}`)
    } else {
        console.log(`[validateStartup] cwd: ${cwd}`)
    }
}

validateStartup()

//#region globals
const builtinsFileName = 'builtinTypes'
const backendMessageDefsFileName = 'backendMessageDefinitions'

const indent = (n: number) => (s: string) => ' '.repeat(n) + s

const alignOnColumn = (pre: string, alignment: number, post: string) => {
    const count = alignment - pre.length
    if (count <= 0) console.warn(`Non-positive alignment count for ${pre}...${post}`)
    return `${pre}${indent(Math.max(0, alignment - pre.length))(post)}`
}

const warning = `/* DO NOT EDIT THIS FILE!!!  It has been generated for your pleasure. */`

// Authentication messages are trickier and will be handled separately
const backendNonAuthenticationFormats = formats.filter(f => f.backend && !f.title.match(/Authentication/))

const nonInternalMessageDefs = new Set(formats.filter(f => !f.internal).map(f => f.title))
const internalMessageDefs = new Set(formats.filter(f => f.internal).map(f => f.title))

//prettier-ignore
const builtinTypes: { [type: string]: { jsType: string; adapterType: string } } = {
    Int32:  { jsType: 'number', adapterType: 'Int32'  },
    Int16:  { jsType: 'number', adapterType: 'Int16'  },
    Int8:   { jsType: 'number', adapterType: 'Int8'   },
    Byte:   { jsType: 'number', adapterType: 'Int8'   },
    Byte1:  { jsType: 'string', adapterType: 'Char'   },
    Char:   { jsType: 'string', adapterType: 'Char'   },
    String: { jsType: 'string', adapterType: 'String' },
}

const dataAdapterImport = "import { DataTypeAdapter } from '../streams/dataTypeAdapter.ts'"
const messageWriterImport = "import { MessageWriterAdapter } from './messageWriterAdapter.ts'"
// prettier-ignore
const imports = `
${dataAdapterImport}
${messageWriterImport}
import {
${[...Object.keys(builtinTypes)].map(t => `${t},`).map(indent(4)).join('\n')}
${[...Object.keys(builtinTypes)].map(t => `parse${t},`).map(indent(4)).join('\n')}
} from './${builtinsFileName}.generated.ts'
`

//#endregion

//#region builtins

const genBuiltins2 = (writer: GenWriter) => {
    compiler.writeLine(dataAdapterImport)
    compiler.newLine()
    const fnWriters: (() => void)[] = []
    for (const name of Object.keys(builtinTypes)) {
        const { jsType, adapterType } = builtinTypes[name]
        if (jsType === undefined) throw new Error(`failed to get jsType for ${name}`)
        if (adapterType === undefined) throw new Error(`failed to get adapterType for ${name}`)

        compiler.writeType(name, jsType, { export_: true })

        const function = new Function_(
            `parse${name}`,
            [new Parameter('adapter', 'DataTypeAdapter')],
            `Promise<${name}>`,
            {
                export_: true,
                arrow_: true,
                const_: true,
                expressionBody_: true,
            }
        )
        const writeBody = (compiler: ITextCompiler) => {
            compiler.writeLine(`adapter.read${adapterType}()`)
        }
        fnWriters.push(() => compiler.writeFunction_(function, writeBody))
    }
    compiler.newLine()
    for (const fnWriter of fnWriters) fnWriter()
    compiler.newLine()
}

//#endregion

//#region ITypeInfo

type TArraySizeInfo = ('Int16' | 'Int32')[]

interface ITypeInfo {
    arraySizeInfo: TArraySizeInfo
    arraySizeInfoString: string
    expected: string | null
    rawName: string
    typeNoArray: string
    typeNoExpected: string
    itemType: string
    typeScriptName: string
}

const getArraySizeInfo: (rawName: string) => TArraySizeInfo = (rawName: string) =>
    [...rawName.matchAll(/\[(Int16|Int32)\]/g)].map(m => m[1]).reverse() as TArraySizeInfo

const arraySizeInfoToString = (info: TArraySizeInfo) =>
    info
        .map(t => `[${t}]`)
        .reverse()
        .join('')

const substrTo = (s: string, c: string) => (s.includes(c) ? s.substring(0, s.indexOf(c)) : s)
const getTypeNoArray = (rawName: string) => substrTo(rawName, '[')
const getTypeNoExpected = (rawName: string) => substrTo(rawName, '(')
const getExpected = (rawName: string) =>
    (rawName.match(/[^(]*\((?<expected>[^)]*)\)/)?.groups ?? {}).expected ?? null

const getTypeScriptName = (rawName: string) => {
    const typeNoExpected = getTypeNoExpected(rawName)
    if (rawName === 'Byte4') {
        return 'Byte[]'
    } else if (typeNoExpected in builtinTypes) {
        return typeNoExpected
    } else if (typeNoExpected.includes('|')) {
        return 'Char'
    } else if (nonInternalMessageDefs.has(typeNoExpected)) {
        return `I${typeNoExpected}`
    } else if (internalMessageDefs.has(typeNoExpected)) {
        return typeNoExpected
    } else if (typeNoExpected.match(/\[\w+\]/)) {
        const typeNoArray = getTypeNoArray(typeNoExpected)
        const baseTypeNoArray: string = getTypeScriptName(typeNoArray)
        const rank = Array.from(typeNoExpected.matchAll(/\[\w+\]/g)).length
        return `${baseTypeNoArray}${'[]'.repeat(rank)}`
    } else {
        throw new Error(`[getTypeScriptTypeName]: Can't convert type: ${typeNoExpected}`)
    }
}

const getTypeInfo: (rawName: string) => ITypeInfo = rawName => {
    const typeScriptName = getTypeScriptName(rawName)
    const typeNoArray = getTypeNoArray(rawName)
    const typeNoExpected = getTypeNoExpected(rawName)
    const itemType = getTypeNoExpected(getTypeNoArray(rawName))
    const arraySizeInfo = getArraySizeInfo(rawName)
    const arraySizeInfoString = arraySizeInfoToString(arraySizeInfo)
    const expected = getExpected(rawName)

    return {
        arraySizeInfo,
        arraySizeInfoString,
        expected,
        itemType,
        rawName,
        typeNoArray,
        typeNoExpected,
        typeScriptName,
    }
}

//#endregion

//#region interfaces

const getBaseInterface = (name: string) => {
    if (name.match(/Authentication/)) return 'IAuthenticationMessage'
    switch (name) {
        case 'IBackendMessage':
        case 'IField':
            return ''
        default:
            return 'IBackendMessage'
    }
}

const getInterfaceProperty = (property: IMessageField, i: number) => {
    if (!property.name) throw new Error(`name missing from definition[${i || 0}]: ${property.definition}`)
    const typeInfo = getTypeInfo(property.type)
    const decl = alignOnColumn(`${property.name}:`, 15, `${typeInfo.typeScriptName}`)
    return alignOnColumn(decl, 30, `// ${property.type}`)
}

const genInterface = (format: IMessageFormat) => {
    const interfaceName = getTypeScriptName(format.title)
    try {
        const properties = format.definition.map(getInterfaceProperty)
        const baseInterface = getBaseInterface(interfaceName)
        const extendsClause = format.frontend || baseInterface === '' ? '' : `extends ${baseInterface} `

        return [
            `export interface ${interfaceName} ${extendsClause}{`,
            ...properties.map(indent(4)),
            `}`,
        ].join('\n')
    } catch (e) {
        throw new Error(`Error creating type ${format.title}: ${e}`)
    }
}

//#endregion

//#region parsers

const getPropertyParser = (property: IMessageField) => {
    const typeInfo = getTypeInfo(property.type)
    // prettier-ignore
    if (typeInfo.typeScriptName in builtinTypes) {
        const adapterType = getBuiltinTypeAttr(typeInfo.typeScriptName, 'adapterType')

        return indent(4)(alignOnColumn(`const ${property.name}`, 20, `= await parse${adapterType}(adapter)`))
    } else if (typeInfo.arraySizeInfo.length > 0) {
        const lines = []
        const sizeInfo = [...typeInfo.arraySizeInfo].reverse()
        for (let loopDepth = 0; loopDepth < sizeInfo.length; ++loopDepth) {
            const i_                = `i_${loopDepth}`
            const count_            = `count_${loopDepth}`
            const result_           = `result_${loopDepth}`
            
            const declareResult     = `const ${result_} = []`
            const parseCount        = `const ${count_} = await parse${sizeInfo[loopDepth]}(adapter)`;
            if (!sizeInfo[loopDepth]) {
                throw new Error(`sizeInfo error: ${JSON.stringify(typeInfo)}`)
            }
            const parseInLoop       = `for (let ${i_} = 0; ${i_} < ${count_}; ++${i_}) {`

            lines.push(...[declareResult, parseCount, parseInLoop].map(indent(4*loopDepth)))
        }
        {
            const result_           = `result_${sizeInfo.length - 1}`
            const parseItem         = `${result_}.push(await parse${typeInfo.typeNoArray}(adapter))`

            lines.push(...[parseItem].map(indent(4 * sizeInfo.length)))
        }
        for (let loopDepth = sizeInfo.length - 2; loopDepth >= 0; --loopDepth) {
            const result_           = `result_${loopDepth}`
            const innerResult_      = `result_${loopDepth + 1}`
            const pushInnerResult   = `${result_}.push(${innerResult_})`

            lines.push(...['}', pushInnerResult].map(indent(4 * (loopDepth + 1))))
        }
        {
            const result_           = `result_0`
            const assignToProp      = `const ${property.name} = ${result_}`

            lines.push('}', assignToProp)
        }
        return lines.map(indent(4)).join('\n')
    } else {
        throw new Error([
            `[getPropertyParser] failed with property:`,
            `${JSON.stringify(typeInfo)}`,
            `${JSON.stringify(property)}`,
        ].join("\n"))
    }
}

const genParser = (format: IMessageFormat) => {
    const hasBaseMessage = !format.internal
    const nonBaseProperties = hasBaseMessage ? format.definition.slice(2) : format.definition.slice()
    const adapter_ = nonBaseProperties.length == 0 ? '_adapter' : 'adapter'
    const messageTypeInfo = getTypeInfo(format.title)
    const parameterList = hasBaseMessage
        ? `${adapter_}: DataTypeAdapter, baseMessage: IBackendMessage`
        : `${adapter_}: DataTypeAdapter`

    const parserType = `(${parameterList}) => Promise<${messageTypeInfo.typeScriptName}>`
    if (nonBaseProperties.length === 0) {
        // prettier-ignore
        return [
            `export const parse${format.title}: ${parserType}`,
            indent(2)( `= (${parameterList}) => Promise.resolve(baseMessage as ${messageTypeInfo.typeScriptName})`),
        ].join('\n')
    } else {
        const propertyParsers = nonBaseProperties.map(getPropertyParser)
        const resultBody = ['...baseMessage', ...nonBaseProperties.map(p => `${p.name}`)].map(s => `${s},`)
        if (!hasBaseMessage) resultBody.shift()

        return [
            `export const parse${format.title}: ${parserType}`,
            indent(2)(`= async (${parameterList}) => {`),
            ...propertyParsers,
            indent(4)('return {'),
            ...resultBody.map(indent(8)),
            indent(4)('}'),
            `}`,
        ].join('\n')
    }
}

//#endregion

//#region main type-guards

const genTypeGuard = (format: IMessageFormat) => {
    const messageTypeInfo = getTypeInfo(format.title)
    const parameterTypeInfo = getTypeInfo(format.definition[0].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(format)}`)
    const open = `export function is${messageTypeInfo.typeScriptName}(message: IBackendMessage): message is ${messageTypeInfo.typeScriptName} {`
    const body = `return message.messageType === ${parameterTypeInfo.expected}`
    const close = '}'
    return [open, indent(4)(body), close].join('\n')
}

//#endregion

//#region authentication

const genBackendAuthenticationParser = () => `
export const parseAuthenticationMessage: (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => Promise<IAuthenticationMessage>
  = async (adapter: DataTypeAdapter, baseMessage: IBackendMessage) => {
    const code = await adapter.readInt32();
    const result: IAuthenticationMessage = { ...baseMessage, code };
    if (code === 5) {
        const salt = [];
        for (let i = 0; i < 4; ++i) {
            salt.push(await adapter.readInt8())
        }
        result.salt = salt;
    }
    return result
}`

const genBackendAuthenticationTypeGuard = (format: IMessageFormat) => {
    const messageTypeInfo = getTypeInfo(format.title)
    const parameterTypeInfo = getTypeInfo(format.definition[2].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(format)}`)
    const open = `export function is${messageTypeInfo.typeScriptName}(message: IBackendMessage): message is ${messageTypeInfo.typeScriptName} {`
    const body = `return isAuthenticationMessage(message) && message.code === ${parameterTypeInfo.expected}`
    const close = '}'
    return [open, indent(4)(body), close].join('\n')
}

const genBackendAuthentication = () => {
    const IAuthenticationMessage_ = `
export interface IAuthenticationMessage extends IBackendMessage {
    messageType:   Byte1          // Byte1('R')
    length:        Int32          // Int32
    code:          Int32          // IField[Int16]
    salt?:         Byte[]
}

${genBackendAuthenticationParser()}

export function isAuthenticationMessage(message: IBackendMessage): message is IAuthenticationMessage {
    return message.messageType === 'R'
}
`
    const getAuthentication = (format: IMessageFormat) =>
        [genInterface(format), genBackendAuthenticationTypeGuard(format)].join('\n\n')
    return [
        IAuthenticationMessage_,
        ...formats.filter(f => f.title.match(/^Authentication/)).map(getAuthentication),
    ].join('\n\n')
}

//#endregion

//#region backendMessageParser

const genCaseForMessage = (format: IMessageFormat) => {
    const messageTypeInfo = getTypeInfo(format.title)
    const parameterTypeInfo = getTypeInfo(format.definition[0].type)
    if (!parameterTypeInfo.expected)
        throw new Error(`Cant make type predicate for def: ${JSON.stringify(format)}`)
    return `case ${parameterTypeInfo.expected}: return parse${messageTypeInfo.rawName}(adapter, baseMessage)`
}

const genBackendMessageParser = () => {
    return `export const parseBackendMessage: (adapter: DataTypeAdapter) => Promise<IBackendMessage> = async (adapter) => {
    const baseMessage = await parseIBackendMessage(adapter)
    switch(baseMessage.messageType) {
        case 'R': return parseAuthenticationMessage(adapter, baseMessage)
${backendNonAuthenticationFormats
    .filter(t => !t.internal)
    .map(genCaseForMessage)
    .map(indent(8))
    .join('\n')}
        default: throw new Error(\`Failed to parse message type: '\$\{baseMessage.messageType\}'\`)
    }
}`
}

//#endregion

//#region frontend message writing

const genMessageWriter = (format: IMessageFormat) => {
    // const messageTypeInterface = genInterface(format)
    // const messageTypeProperties = format.definition.map(getInterfaceProperty)
    const nonDefaultProperties = format.definition.filter(
        p => p.name !== 'length' && p.name !== 'messageType'
    )

    const messageTypeParameterList = nonDefaultProperties.map(property => {
        const propertyTypeInfo = getTypeInfo(property.type)
        return `${property.name}: ${propertyTypeInfo.typeScriptName}`
    })

    const mapPropertyToTvItem = (property: IMessageField, valueAsExpected = false) => {
        const typeInfo = getTypeInfo(property.type)
        const expected = (typeInfo.expected?.match(/'(.)'|(\d+)/) || [null, null])[1]
        if (expected === null && valueAsExpected)
            throw new Error(`[mapPropertyToTvItem] invalid expected value: ${JSON.stringify(property)}`)

        const type = typeInfo.itemType === 'Byte1' ? 'Int8' : typeInfo.itemType

        const value = !valueAsExpected
            ? property.name
            : typeof expected === 'string'
            ? expected.charCodeAt(0)
            : expected

        const sizeInfo = typeInfo.arraySizeInfoString ? `${typeInfo.arraySizeInfoString}` : ''

        return alignOnColumn(
            `{type: '${type}',`,
            20,
            alignOnColumn(`name: '${property.name}',`, 23, `value: ${value}}`)
        )
    }

    const messageTypeTVList = nonDefaultProperties.map(p => mapPropertyToTvItem(p, false))

    const messageTypeProperty = format.definition.find(p => p.name === 'messageType')
    if (messageTypeProperty) {
        messageTypeTVList.unshift(mapPropertyToTvItem(messageTypeProperty, true))
        // const messageTypeTypeInfo = getTypeInfo(messageTypeProperty.type)
        // const expected = (messageTypeTypeInfo.expected?.match(/'(.)'|(\d+)/) || [null, null])[1]
        // if (expected === null) {
        //     throw new Error(`[genMessageWriter] invalid expected message type: ${JSON.stringify(format)}`)
        // } else {
        //     const _expected = typeof expected === 'string' ? expected.charCodeAt(0) : expected
        //     const _type = messageTypeTypeInfo.itemType === 'Byte1' ? 'Int8' : messageTypeTypeInfo.itemType
        //     messageTypeTVList.unshift(`{type: '${_type}', name: 'messageType', value: ${_expected} }`)
        // }
    }

    const parameterList = [`messageWriterAdapter: MessageWriterAdapter`, ...messageTypeParameterList]
    const writerType = `(${parameterList.join(', ')}) => Promise<void>`

    const messageWriter = `
export const write${format.title}: ${writerType}
  = (
${parameterList.map(indent(4)).join(',\n')}
) => messageWriterAdapter.writeMessage([
${messageTypeTVList.map(indent(8)).join(',\n')}
])
`
    return messageWriter
    // return [messageTypeInterface, messageWriter].join('\n\n')
}

//#endregion

//#region main()

const genFile = (fileName: string, genFile: () => string) => {
    const path = `./src/messages/${fileName}.generated.ts`
    console.log(`[genFile] Generating file ${fileName} ...`)
    /// FILE
    const file = `${warning}\n${genFile()}\n${warning}`
    writeFileSync(path, file)
    console.log(`[genFile] Generating file ${fileName} complete`)
}

const genFile2 = (fileName: string, writeFile: (writer: GenWriter) => void) => {
    const path = `./src/messages/${fileName}.generated.ts`
    console.log(`[genFile2] Generating file ${fileName} ...`)
    const writer = new GenWriter()
    writeFile(writer)
    /// FILE
    const file = `${warning}\n${compilercompile()}\n${warning}`
    writeFileSync(path, file)
    console.log(`[genFile2] Generating file ${fileName} complete`)
}

const getCodeForMessage = (format: IMessageFormat) => {
    const header = `/// ${format.title}`
    const interface_ = genInterface(format)
    const parser = genParser(format)
    const typeGuard = format.internal ? '// No type guard' : genTypeGuard(format)
    return [header, interface_, parser, typeGuard].join('\n\n')
}

const genBackendMessageDefs = () => `${imports}
///#region Backend Message Defs

${backendNonAuthenticationFormats.map(getCodeForMessage).join('\n\n')}

///#endregion

//#region Authentication
${genBackendAuthentication()}

//#endregion

${genBackendMessageParser()}

//#region Frontend Writers

${formats
    .filter(f => f.frontend)
    .map(genMessageWriter)
    .join('\n\n')}

//#endregion

`

genFile(builtinsFileName, genBuiltins)
genFile(backendMessageDefsFileName, genBackendMessageDefs)

genFile2('builtin2', genBuiltins2)

//#endregion
